{% extends "standbase/base.html" %}

{% block head %}Home{% endblock %}

{% block extrahead %}
{% endblock %}

{% block content %}

<div class="page-header">
	<h1>Standing</h1>
	<p class="lead">Standing is an app for playful acts of resistance. Grab the app, go outside and get standing for a cause.</p>
</div>

<h2>Recent sessions</h2>
<div class="row">
	<div class="col-md-6">
		<div class="list-group" id="sessions">

		{% comment %}
		{% for session in active_sessions %}
			<a class="list-group-item active" id="session_{{ session.id }}"><span class="livetime">x seconds</span> for <strong>something</strong> <small>in {{ session.parsed_geocode.1 }} {{ session.datecreated|timesince }} ago</small></a>
		{% endfor %}
		{% endcomment %}

		{% for session in completed_sessions %}
			<a class="list-group-item" id="session_{{ session.id }}" href="{{ session.get_absolute_url }}" id="">{{ session.datefinished|timeuntil:session.datecreated }} for <strong>{{ session.topic }}</strong> <small>in {{ session.parsed_geocode.1 }} {{ session.datecreated|timesince }} ago</small></a>
		{% endfor %}
		</div>
	</div>

	<div class="col-md-6">
		<div id="map"></div>
	</div>
</div>

<h2>Trending causes</h2>
<div class="list-group">
	{% for topic in trending_topics %}
	<a class="list-group-item" href="{{ topic.get_absolute_url }}">{{ topic.name }} <small>{{ topic.duration }} seconds</small></a>
	{% endfor %}
</div>

{% include "standbase/footer.html" %}

{% endblock content %}

{% block extra_javascript %}
<script type="text/javascript">

	var active_sessions = {};

	{% comment %}
	{% for session in active_sessions %}
	active_sessions[{{ session.id }}] = {
		'datecreated': new Date('{{ session.datecreated|date:"Y-m-d\TH:i:sO" }}'),
		'lat': {{ session.lat }},
		'lon': {{ session.lon }}
	};
	{% endfor %}
	{% endcomment %}

	$(document).ready(function() {
		// Update seconds on all the active sessions
		setInterval(updateCounters, 1000);

		setInterval(getCurrentState, 10000);

		getCurrentState();
		updateCounters();
	});
	
	function getActiveSession() {
		for (var key in active_sessions) {
			return active_sessions[key];
		}
	}
	
	function updateCounters() {
		// Walk through all the active sessions and update the counters in #active_time_id
		for (var key in active_sessions) {
			var now = new Date();
			var datecreated = new Date(active_sessions[key]['datecreated']);

			var seconds = Math.round((now.getTime() - datecreated.getTime()) / 1000);
			$('#session_' + key + ' .livetime').text('' + seconds + ' seconds');
		}
	}

	function getCurrentState() {
		console.log("Got new state");

		$.getJSON('/api/state', function(data, textStatus, jqXHR) {
			console.log(data);

			// Process incoming sessions
			for (var i = 0; i < data['active_sessions'].length; i++) {
				var s = data['active_sessions'][i];

				if (s['id'] in active_sessions) {
					// The id is already in there
					// Probably nothing has to be done
				} else {
					// This session is new because it's not in the array anymore

					// Add it to the array
					active_sessions[s['id']] = s;

					// Render it on the top of the list
					$('#sessions A:first').prepend('<a class="list-group-item active" id="session_' + s['id'] + '"><span class="livetime">x seconds</span> for <strong>[unknown]</strong> <small>in {{ session.parsed_geocode.1 }} {{ session.datecreated|timesince }} ago</small></a>');
				}
			}

			// Cull active sesssions we still have which aren't active anymore
			// By checking which keys in our currently active sessions are not in the incoming
			for (var key in active_sessions) {

				var present = false;
				for (var i = 0; i < data['active_sessions'].length; i++) {
					if (data['active_sessions'][i]['id'] == key) {
						present = true;
						break;
					}
				}

				if (!present) {
					// Remove this id from sessions
					$('#session_' + key).slideUp();
				}
			}

			for (var i = 0; i < data['completed_sessions'].length; i++) {
				processIncomingCompletedSession(data['completed_sessions'][i]);
			}
		});
	}


	function processIncomingCompletedSession(s) {

	}

	function checkForFinishedSessions() {
		// Once every minute poll to see if any sessions have finished
		// Will return an array of the sessions active right now

		// TODO also update the recently completed sessions
	}

</script>
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css" />
<script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js"></script>
<script src="{{ STATIC_URL }}js/leaflet-layer-plugins/tile/Bing.js"></script>
<script type="text/javascript">
	if (!$.isEmptyObject(active_sessions)) {
		var map = L.map('map').setView([getActiveSession()['lat'], getActiveSession()['lon']], 13);

		var bing = new L.BingLayer("AuqUZRCmpMVOY8D8je-TB8URkqLGVeFx8jpFNURcbNmfeQaA-k0wW7kWIAq__HzG");

		// L.tileLayer('http://{s}.tile.cloudmade.com/d835804aba7d4dea8039b3f6c6b8b23e/997/256/{z}/{x}/{y}.png', {
		// 	attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://cloudmade.com">CloudMade</a>',
		// 	maxZoom: 18
		// }).addTo(map);

		map.addLayer(bing);

		var markers = [];

		for (var key in active_sessions) {
			var s = active_sessions[key];
			markers.push(L.marker([s['lat'], s['lon']]).addTo(map));
		}

		var group = new L.featureGroup(markers);
		map.fitBounds(group.getBounds());
	}
</script>
{% endblock extra_javascript %}